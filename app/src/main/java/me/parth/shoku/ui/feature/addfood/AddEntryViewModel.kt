package me.parth.shoku.ui.feature.addfood

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import me.parth.shoku.domain.model.LoggedEntry
import me.parth.shoku.domain.repository.FoodRepository
import javax.inject.Inject

@HiltViewModel
class AddEntryViewModel @Inject constructor(
    private val foodRepository: FoodRepository
) : ViewModel(), MviViewModel<AddFoodContract.UiState, AddFoodContract.Intent, AddFoodContract.Effect> {

    private val _uiState = MutableStateFlow(AddFoodContract.UiState())
    override val uiState = _uiState.asStateFlow()

    private val _effect = Channel<AddFoodContract.Effect>(Channel.BUFFERED)
    override val effect = _effect.receiveAsFlow()

    override fun onIntent(intent: AddFoodContract.Intent) {
        when (intent) {
            is AddFoodContract.Intent.UpdateFoodName -> _uiState.update { it.copy(foodName = intent.name) }
            is AddFoodContract.Intent.UpdateQuantity -> _uiState.update { it.copy(quantity = intent.quantity) }
            is AddFoodContract.Intent.UpdateUnit -> _uiState.update { it.copy(unit = intent.unit) }
            is AddFoodContract.Intent.UpdateCalories -> _uiState.update { it.copy(calories = intent.calories) }
            is AddFoodContract.Intent.UpdateProtein -> _uiState.update { it.copy(protein = intent.protein) }
            is AddFoodContract.Intent.UpdateSelectedMeal -> _uiState.update { it.copy(selectedMeal = intent.meal) }
            is AddFoodContract.Intent.UpdateNotes -> _uiState.update { it.copy(notes = intent.notes) }
            AddFoodContract.Intent.SaveEntry -> saveEntry()
        }
    }

    private fun saveEntry() {
        val currentState = _uiState.value
        val quantity = currentState.quantity.toDoubleOrNull()
        val calories = currentState.calories.toDoubleOrNull()
        val protein = currentState.protein.toDoubleOrNull()

        // Basic Validation
        if (currentState.foodName.isBlank() || quantity == null || calories == null || protein == null || quantity <= 0) {
            sendEffect(AddFoodContract.Effect.ShowError("Please fill in all required fields correctly (Name, Quantity > 0, Calories, Protein)."))
            return
        }

        val entry = LoggedEntry(
            // id is generated by Room
            foodName = currentState.foodName.trim(),
            quantity = quantity,
            unit = currentState.unit,
            calories = calories,
            protein = protein,
            meal = currentState.selectedMeal,
            notes = currentState.notes.takeIf { it.isNotBlank() },
            // date defaults to LocalDate.now() in the model
            // foodItemId will be handled by repository if needed
        )

        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                foodRepository.addLoggedEntry(entry) // Call the repository's method
                sendEffect(AddFoodContract.Effect.EntrySavedSuccessfully)
                // Optionally clear the form
                 _uiState.value = AddFoodContract.UiState() // Reset state
            } catch (e: Exception) {
                // Log the exception e
                sendEffect(AddFoodContract.Effect.ShowError("Failed to save entry: ${e.localizedMessage}"))
            } finally {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }

    private fun sendEffect(effectToSend: AddFoodContract.Effect) {
        viewModelScope.launch {
            _effect.send(effectToSend)
        }
    }
}

// Extend ViewModel to handle intents easily from UI
interface MviViewModel<S, I, E> {
    val uiState: StateFlow<S>
    val effect: Flow<E>
    fun onIntent(intent: I)
} 